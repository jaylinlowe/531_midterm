---
title: "Complexity of US Baby Names"
output: html_document
author: Jaylin Lowe, Xinhe Wu, and Yiheng Xiang
bibliography: unblinded.bib
csl: apa-numeric-superscript-brackets.csl
editor_options: 
  chunk_output_type: inline
---

```{r, echo = FALSE, message = FALSE}
#import packages
library(babynames)
library(dplyr)
library(ggplot2)
library(stringr)
library(forecast)
```

```{r, echo = F}
#code borrowed from slides, modified with try-catch 
aic_table <- function(data, P, Q, D = 0, xreg = NULL) {
  table <- matrix(NA, (P+1), (Q + 1)) 
  for (p in 0:P) {
    for (q in 0:Q) {
      
      if (is.null(xreg)) {
        table[p+1, q+1] <- tryCatch({arima2::arima(data, order = c(p, D, q))$aic},
        error = function(e){
          print(c(p,q))
          print(e) 
          NA},
        warning = function(w) {
          print(c(p,q))
          print(w)
          NA
        })
      }
      else{
        table[p+1, q+1] <- tryCatch({arima2::arima(data, order = c(p, D, q), xreg = xreg, max_iters = 500)$aic},
        error = function(e){
          print(c(p,q))
          print(e) 
          NA},
        warning = function(w) {
          print(c(p,q))
          print(w)
          NA
        })
      }
    }
  }
  dimnames(table) <- list(paste("AR", 0:P, sep = ""),
                          paste("MA", 0:Q, sep = ""))
  return(table)
}
```


# Introduction

Every year, names US parents choose for their children seem to get more unusual and more complex. The decision of what to name your baby has become so complex that some people choose to hire naming consultants to help them find unique names [@nyt]. However, this phenomenon is mostly ancedotal and may be influenced by the number of celebrities choosing extremely unusual and complicated names for this children. In this project, we set out to explore how the complexity of US baby names has changed over time. Are names actually becoming more complex? 

To answer this question, we created three different time series, separated by gender, using data from the US Social Security Administration on first names given to babies born between 1880 and 2017 [@babynames]. Names given to fewer than five babies of the same gender in the same year are excluded; all others are included. As a result, we cannot observe trends in extremely unusual names; however, we can still observe general naming trends. The dataset gives us the number of babies given a particular name, divided by gender and year. 

For each year and sex, we calculated three values aimed at capturing the complexity of names. These three were: the average length of a name, the average number of vowels in a name, and the average longest run of consonants in a name. These were weighted by how popular a name was. In other words, the denominator for these averages was the number of people born that year, not the number of unique names given. Popular names will be given more weight than unusual names. The first two values are fairly self-explanatory, but the third may benefit from an example. For each name, we calculated the longest run of consonants in a name. For example, the name "Isabella" has a longest consonant run of 2, from the "ll" part. The names "Ava" and "Astrid" would have a longest consonant run of 1 and 3, respectively. 

We chose these questions because they seemed to address the question of "complexity" while being fairly easy to calculate and intuitive to explain. "Complexity" can mean very different things when it comes to names. We would generally consider very long names to be complex, but short names with a lot of consonants in a row might also fall under "complex names" especially if the repeated consonants make the name hard to pronounce. We initially got the idea to do average length and average vowel count from a data visualization we found [@data_viz] and came up with the idea for longest consonant run on our own. 

# Exploratory Data Analysis 

We start by exploring what these time series look like visually. First, we plot the average length of the names of all babies born 1880-2017, separated by sex. 


```{r, echo = FALSE, message = F, warning = F}
length_df2 <- babynames %>%
  mutate(name_length = str_length(name)) %>%
  mutate(name_length_people = name_length * n) %>%
  group_by(year, sex) %>%
  summarize(avg_length = sum(name_length_people)/sum(n)) 

ggplot(length_df2, aes(x = year, y = avg_length, color = sex)) + geom_line() +
scale_color_manual(values = c("purple2", "mediumaquamarine")) + 
  labs(x = "Year", y = "Length", color = "Sex") + 
  ggtitle("Average length of first name, by year") + 
  theme_classic() + theme(legend.position = "bottom") 

```

The plots look fairly similar for both sexes. There appears to be a general increase in the average length in a name, peaking around the 1990s. 

Next, we plot the average number of vowels in the names of all babies, again separated by sex:
```{r, echo = F, message = F, warning = F}
vowel_df2 <- babynames %>%
  mutate(num_vowels = str_count(name, '[aeoiuAEOIU]')) %>%
  mutate(num_vowels_people = num_vowels * n) %>%
  group_by(year, sex) %>%
  summarize(avg_num = sum(num_vowels_people)/sum(n)) 

ggplot(vowel_df2, aes(x = year, y = avg_num, color = sex)) + geom_line() +
  scale_color_manual(values = c("purple2", "mediumaquamarine")) + 
  labs(x = "Year", y = "Number of Vowels", color = "Sex") + 
  ggtitle("Average number of vowels in first name, by year") + 
  theme_classic() + theme(legend.position = "bottom") 

```

Here, the overall shape of the time series looks very similar for male and female babies. There might be an overall slight increase from 1880 to 2017, but there also appears to be a decrease around the 1960s. It is also worth noting that this plot is markedly different from the previous one. You might have initially expected that the average number of vowels would look similar to the average length of a name, since longer names likely require more vowels. However, this is not the case. 

Next, we plot the average longest consonant run in the names of all babies, again separated by sex:

```{r, echo = F, message = F, warning = F, cache = T}
longest_run <- rep(NA, nrow(babynames))
for (i in 1:nrow(babynames)) {
  name <- babynames$name[i]
  longest_run[i] <- max(sapply(str_split(name, "[!aeiouAEIOU]")[[1]], nchar))
}

consonant_run_df <- babynames %>%
  mutate(longest_run = longest_run) %>%
  group_by(year, sex) %>%
  summarize(weighted_longest_run = sum(n * longest_run)/sum(n)) 


ggplot(aes(x = year, y = weighted_longest_run, color = sex), data = consonant_run_df) + 
  geom_line() + 
  scale_x_continuous(breaks = c(seq(1880, 2017, 10), 2017)) +
  scale_y_continuous(breaks = c(1.7, seq(1.75, 1.95, 0.05), 2.0), limits = c(1.7, 2)) + 
  scale_color_manual(values = c("purple2", "mediumaquamarine")) + 
  labs(x = "Year", y = "Number of Consonants", color = "Sex") + 
  ggtitle("Average max number of consonants in a row in first name, by year") + 
  theme_classic() + theme(legend.position = "bottom") 

```

For both sexes, there appears to be a dramatic decrease in the average longest consonant run starting in the 1990s. Prior to that, there appears to be a slight increase for female babies while the values for male babies stay fairly constant. The peak here appears to be around the same time as the peak for average length, which makes sense since shorter names also means shorter runs of consonants. However, the graphs are still fairly different. 

Calculating these values and plotting them required some additional sources, including documentation for the `stringr` and `ggplot2` packages and a couple chatGPT queries [@stringr; @ai1; @ai2; @ggplot]. 



# Modeling

## Average Name Length

## Average Number of Vowels

## Average Longest Run of Consonants 

We will fit a model for females and males separately. Looking at the graphs, the time series for the average longest consonant run for female names appears to have a non-linear trend. As a result, we start by fitting a cubic polynomial to the female name data to de-trend it. We originally tried a quadratic, but this did not appear to fit the data properly. The graph below shows the original female name data versus the fitted values (dotted line) from the cubic polynomial: 

```{r, echo = F}
consonant_female <- filter(consonant_run_df, sex == "F")

ts_female <- ts(consonant_female$weighted_longest_run,
                start = min(consonant_female$year), 
                end   = max(consonant_female$year),
                frequency = 1)

lm_trend_female <- tslm(ts_female ~ trend+I(trend^2) + I(trend^3))

plot_df <- data.frame(year = seq(1880, 2017, by = 1), orig = c(ts_female), fitted = c(fitted(lm_trend_female)))

ggplot(plot_df) + geom_line(aes(y = orig, x = year), color = "purple2") + geom_line(aes(y = fitted, x = year), color = "black", linetype = "dotted") + labs(x = "Year", y = "Number of Consonants") + ggtitle("Female: Observed Max Consonant Run vs. Fitted Cubic Values")
```

Now, we fit an $ARMA(p,q)$ model to the residuals created from the cubic polynomial. To choose $p$ and $q$, we consider $p \in (0,5)$ and $q \in (0,5)$ and calculate the AIC for each resulting model. We use a modified version of the code shown in class [@notes531] that inserts a `NA` value for any $p,q$ combinations that produce errors or warnings. Note that we are using `arima2` [@arima2] to help avoid optimization issues. 

```{r, echo = F, warning = F, message = F, include = F}
set.seed(49282)
resid_female <- residuals(lm_trend_female)
detrend_female <- aic_table(resid_female, P = 5, Q = 5, D = 0)
```

```{r, echo = F}
knitr::kable(detrend_female, caption = "AIC Table for Detrended Female Max Consonant Run Data")
```
In this particular case, the NAs are generated by a convergence warning. As a result, we will avoid $p, q \geq 4$. The table suggests that the best model is an $ARMA(3,1)$ model. However, if we plot the inverse roots of this model, we notice that some of the roots are on the border of the unit circle:

```{r, echo = F}
plot(arima2::arima(resid_female, order = c(3, 0, 1))) + ggtitle("Inverse Roots For ARMA(3,1) Model")
```

The same is true for an $ARMA(2,2)$ model. However, if we try an $ARMA(2,1)$ model, which also had a fairly small AIC, we no longer have this issue:

```{r, echo = F}
plot(arima2::arima(resid_female, order = c(2, 0, 1))) + ggtitle("Inverse Roots For ARMA(2,1) Model")
```

Interestingly, an $ARMA(2,1)$ model is also what the `auto.arima` model from the `forecast` package [@forecast] suggests. Given that this model does not have the invertibility problems of models with larger $p$ and $q$, we will choose this $ARMA(2,1)$ model fit to the residuals of a cubic polynomial as our final model. 




# Conclusion? Discussion? 

# Contributions 

# Scholarship 
Put our project in context of others? 

**<big>References</big>**.




